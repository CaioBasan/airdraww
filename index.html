<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>AirDraw ‚Äî Desenho no Ar (Webcam + M√£os)</title>
  <meta name="description" content="Desenhe no ar em tempo real usando detec√ß√£o de m√£os (MediaPipe Hands). Single-file, front-end only.">
  <style>
    :root {
      --bg: #0f172a;           /* slate-900 */
      --panel: #111827;        /* gray-900 */
      --muted: #94a3b8;        /* slate-400 */
      --text: #e5e7eb;         /* gray-200 */
      --accent: #22d3ee;       /* cyan-400 */
      --accent-2: #8b5cf6;     /* violet-500 */
      --danger: #ef4444;       /* red-500 */
      --ok: #10b981;           /* emerald-500 */
      --shadow: 0 10px 30px rgba(0,0,0,.35);
    }
    * { box-sizing: border-box }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 70% -10%, rgba(34,211,238,.15), transparent 60%),
                               radial-gradient(900px 600px at -10% 20%, rgba(139,92,246,.12), transparent 50%),
                               var(--bg);
      color: var(--text); font: 15px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
      overflow: hidden;
    }
    .app {
      display: grid; grid-template-columns: 320px 1fr; grid-template-rows: auto 1fr; gap: 12px; height: 100%; padding: 12px;
    }
    header {
      grid-column: 1 / -1; display: flex; align-items: center; justify-content: space-between; padding: 10px 14px; background: rgba(17,24,39,.6);
      border: 1px solid rgba(255,255,255,.06); border-radius: 16px; box-shadow: var(--shadow); backdrop-filter: blur(8px);
    }
    header .title { display: flex; align-items: center; gap: 10px; }
    .badge { padding: 4px 8px; border-radius: 999px; background: rgba(34,211,238,.15); color: var(--accent); border: 1px solid rgba(34,211,238,.25); font-weight: 600; font-size: 12px; }
    .muted { color: var(--muted); font-size: 13px; }

    .panel { background: rgba(17,24,39,.6); border: 1px solid rgba(255,255,255,.06); border-radius: 16px; padding: 12px; box-shadow: var(--shadow); backdrop-filter: blur(6px); }
    .controls { display: grid; gap: 12px; height: calc(100vh - 120px); overflow: auto; }
    .group { background: rgba(255,255,255,.02); border: 1px solid rgba(255,255,255,.06); border-radius: 14px; padding: 12px; }
    .group h3 { margin: 0 0 8px; font-size: 14px; letter-spacing: .3px; text-transform: uppercase; color: var(--muted); }

    label { display: grid; gap: 6px; margin: 8px 0; font-size: 13px; color: var(--text); }
    input[type="range"] { width: 100%; }
    input[type="color"], input[type="text"], input[type="number"], button, .toggle {
      background: #0b1220; border: 1px solid rgba(255,255,255,.08); color: var(--text); padding: 8px 10px; border-radius: 10px;
      outline: none; box-shadow: inset 0 1px 0 rgba(255,255,255,.05), var(--shadow);
    }
    input[type="text"] { width: 100%; }

    .row { display: flex; gap: 8px; align-items: center; }
    .row > * { flex: 1; }

    .btn { cursor: pointer; display: inline-flex; align-items: center; justify-content: center; gap: 8px; padding: 10px 12px; font-weight: 600; }
    .btn:disabled { opacity: .5; cursor: not-allowed; }
    .btn.primary { background: linear-gradient(135deg, rgba(34,211,238,.25), rgba(139,92,246,.25)); border-color: rgba(34,211,238,.35); }
    .btn.danger { border-color: rgba(239,68,68,.45); background: rgba(239,68,68,.12); }

    .workspace { position: relative; overflow: hidden; border-radius: 16px; }
    .stage { position: relative; width: 100%; height: calc(100vh - 120px); background: #000; border-radius: 16px; }

    /* Video and canvases */
    #video { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: cover; transform: scaleX(var(--mirror, 1)); }
    #drawCanvas, #hudCanvas { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }

    /* Holograma */
    .holo { position: absolute; right: 14px; bottom: 14px; width: 220px; background: rgba(3,7,18,.75); border: 1px solid rgba(255,255,255,.06); border-radius: 14px; padding: 8px; box-shadow: var(--shadow); }
    #holoCanvas { display: block; width: 100%; height: auto; background: radial-gradient(150px 150px at 50% 30%, rgba(34,211,238,.1), rgba(139,92,246,.08)); border-radius: 10px; }
    .status { display: flex; align-items: center; justify-content: space-between; font-size: 12px; color: var(--muted); margin-top: 6px; }
    .dot { display: inline-block; width: 8px; height: 8px; border-radius: 999px; margin-right: 6px; background: #555; }
    .dot.ok { background: var(--ok); }
    .dot.warn { background: var(--danger); }

    /* Shortcuts */
    .kbd { display: inline-flex; align-items: center; justify-content: center; min-width: 24px; padding: 2px 6px; border-radius: 6px; background: #0b1220; border: 1px solid rgba(255,255,255,.1); font-weight: 700; }

    /* Toast */
    .toast { position: fixed; left: 50%; transform: translateX(-50%); bottom: 16px; background: rgba(3,7,18,.9); padding: 10px 12px; border: 1px solid rgba(255,255,255,.08); border-radius: 12px; box-shadow: var(--shadow); display: none; }

    /* Modal */
    dialog { border: none; border-radius: 12px; padding: 0; color: var(--text); background: rgba(17,24,39,.98); border: 1px solid rgba(255,255,255,.08); box-shadow: var(--shadow); }
    dialog .box { padding: 16px; max-width: 420px; }
    dialog::backdrop { background: rgba(0,0,0,.5); }

    /* Accessibility focus */
    :focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr; }
      .controls { height: auto; max-height: 40vh; }
      .stage { height: 55vh; }
      .holo { width: 180px; }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="AirDraw ‚Äî desenhe no ar com a webcam">
    <header>
      <div class="title">
        <span class="badge" aria-hidden>AirDraw</span>
        <div>
          <div style="font-weight:800; letter-spacing:.4px;">Desenho no ar (Webcam + M√£os)</div>
          <div class="muted">Tudo local no navegador ‚Ä¢ MediaPipe Hands ‚Ä¢ 720p</div>
        </div>
      </div>
      <div class="muted">Atalhos: <span class="kbd">D</span> desenhar ‚Ä¢ <span class="kbd">E</span> borracha ‚Ä¢ <span class="kbd">C</span> limpar ‚Ä¢ <span class="kbd">S</span> salvar ‚Ä¢ <span class="kbd">M</span> espelhar ‚Ä¢ <span class="kbd">+</span>/<span class="kbd">-</span> espessura</div>
    </header>

    <aside class="panel">
      <div class="controls" id="controls">
        <div class="group" aria-labelledby="brushGroup">
          <h3 id="brushGroup">Pincel</h3>
          <div class="row">
            <label>Cor
              <input id="color" type="color" value="#22d3ee" aria-label="Cor do pincel" />
            </label>
            <label>Hex
              <input id="hex" type="text" value="#22d3ee" aria-label="C√≥digo hexadecimal" />
            </label>
          </div>
          <label>Espessura: <span id="thicknessLabel">6</span> px
            <input id="thickness" type="range" min="1" max="60" value="6" aria-label="Espessura do tra√ßo" />
          </label>
          <div class="row">
            <button id="toggleDraw" class="btn primary" aria-pressed="false" aria-label="Alternar desenho (D)">‚úçÔ∏è Caneta: <b id="penState">OFF</b></button>
            <button id="eraser" class="btn" aria-pressed="false" aria-label="Alternar borracha (E)">üßΩ Borracha</button>
          </div>
        </div>

        <div class="group" aria-labelledby="gestureGroup">
          <h3 id="gestureGroup">Gestos & Sensibilidade</h3>
          <p class="muted" style="margin:0 0 6px;">Junte <b>polegar + indicador</b> para desenhar (caneta abaixada). Abra a m√£o para pausar.</p>
          <label>Sensibilidade do gesto (dist√¢ncia para ativar): <span id="sensitivityLabel">0.045</span>
            <input id="sensitivity" type="range" min="0.02" max="0.09" step="0.001" value="0.045" aria-label="Sensibilidade do rastreamento" />
          </label>
          <label>Suaviza√ß√£o do tra√ßo (EMA): <span id="smoothLabel">0.35</span>
            <input id="smoothing" type="range" min="0.05" max="0.9" step="0.05" value="0.35" aria-label="Suaviza√ß√£o do tra√ßo" />
          </label>
        </div>

        <div class="group" aria-labelledby="videoGroup">
          <h3 id="videoGroup">V√≠deo</h3>
          <div class="row">
            <button id="mirror" class="btn" aria-pressed="true" aria-label="Espelhar v√≠deo (M)">ü™û Espelhar: <b id="mirrorState">ON</b></button>
            <button id="restartCam" class="btn" aria-label="Reiniciar c√¢mera">‚ôªÔ∏è Reiniciar</button>
          </div>
          <label>Resolu√ß√£o
            <select id="resolution" aria-label="Selecionar resolu√ß√£o">
              <option value="1280x720" selected>1280√ó720</option>
              <option value="1920x1080">1920√ó1080</option>
              <option value="640x480">640√ó480</option>
            </select>
          </label>
        </div>

        <div class="group" aria-labelledby="fileGroup">
          <h3 id="fileGroup">Arquivo</h3>
          <div class="row">
            <button id="saveArt" class="btn primary" aria-label="Salvar PNG da arte (sem v√≠deo)">üíæ Salvar PNG (arte)</button>
            <button id="saveWithVideo" class="btn" aria-label="Salvar PNG com v√≠deo de fundo">üñºÔ∏è Salvar com v√≠deo</button>
          </div>
          <button id="clear" class="btn danger" aria-label="Limpar desenho (C)">üóëÔ∏è Limpar tudo</button>
        </div>

        <div class="group" aria-labelledby="shortcutsGroup">
          <h3 id="shortcutsGroup">Atalhos</h3>
          <div class="muted">
            <p><span class="kbd">D</span> alterna caneta ‚Ä¢ <span class="kbd">E</span> borracha ‚Ä¢ <span class="kbd">C</span> limpar ‚Ä¢ <span class="kbd">S</span> salvar ‚Ä¢ <span class="kbd">M</span> espelhar ‚Ä¢ <span class="kbd">+</span>/<span class="kbd">-</span> espessura</p>
          </div>
        </div>

        <div class="group" aria-labelledby="aboutGroup">
          <h3 id="aboutGroup">Sobre</h3>
          <p class="muted" style="margin:0">Processamento 100% local. Se a c√¢mera n√£o abrir, veja a mensagem de erro ‚Äî navegadores exigem <b>origem segura</b> (https/localhost) para acessar a webcam.</p>
        </div>
      </div>
    </aside>

    <main class="workspace">
      <div class="stage panel" aria-live="polite">
        <video id="video" playsinline muted></video>
        <canvas id="drawCanvas"></canvas>
        <canvas id="hudCanvas" aria-hidden="true"></canvas>

        <div class="holo" aria-label="Holograma de m√£o">
          <canvas id="holoCanvas" width="220" height="220"></canvas>
          <div class="status">
            <div><span id="handDot" class="dot"></span><span id="handStatus">M√£o n√£o detectada</span></div>
            <div id="fps">0 fps</div>
          </div>
          <div class="status"><div>Caneta: <b id="penStatus">OFF</b></div><div class="muted" id="mirrorMini">Mirror ON</div></div>
        </div>
      </div>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <dialog id="confirmClear">
    <div class="box">
      <h3>Limpar tudo?</h3>
      <p class="muted">Isso remover√° todo o desenho atual. Essa a√ß√£o n√£o pode ser desfeita.</p>
      <div class="row">
        <button class="btn danger" id="doClear">Apagar</button>
        <button class="btn" id="cancelClear">Cancelar</button>
      </div>
    </div>
  </dialog>

  <!-- MediaPipe Hands (est√°vel no Chrome). CDN oficial. -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.min.js"></script>

  <script>
  (function(){
    'use strict';

    /*** UTIL ***/
    const $ = sel => document.querySelector(sel);
    const video = $('#video');
    const drawCanvas = $('#drawCanvas');
    const hudCanvas = $('#hudCanvas');
    const holoCanvas = $('#holoCanvas');
    const ctxDraw = drawCanvas.getContext('2d');
    const ctxHUD = hudCanvas.getContext('2d');
    const ctxHolo = holoCanvas.getContext('2d');

    const ui = {
      color: $('#color'), hex: $('#hex'), thickness: $('#thickness'), thicknessLabel: $('#thicknessLabel'),
      smoothing: $('#smoothing'), smoothLabel: $('#smoothLabel'), sensitivity: $('#sensitivity'), sensitivityLabel: $('#sensitivityLabel'),
      toggleDraw: $('#toggleDraw'), eraser: $('#eraser'), clear: $('#clear'), saveArt: $('#saveArt'), saveWithVideo: $('#saveWithVideo'),
      mirror: $('#mirror'), mirrorState: $('#mirrorState'), mirrorMini: $('#mirrorMini'), restartCam: $('#restartCam'), resolution: $('#resolution'),
      penState: $('#penState'), penStatus: $('#penStatus'), handStatus: $('#handStatus'), handDot: $('#handDot'), fps: $('#fps'),
      toast: $('#toast'), confirm: $('#confirmClear'), doClear: $('#doClear'), cancelClear: $('#cancelClear')
    };

    let state = {
      running: false,
      mirror: true,
      penDown: false, (void 0),
      erasing: false,
      lastPt: null,
      ema: 0.35, // smoothing alpha
      pinchThreshold: 0.045, // in normalized units (0..1 of image width)
      brush: { color: '#22d3ee', width: 6 },
      fps: 0,
      lastFrameTime: performance.now(),
      size: { w: 1280, h: 720 },
      landmarks: null,
      handPresent: false
    };

    // Resize canvases to video container size
    function fitCanvases(){
      const rect = video.getBoundingClientRect();
      const w = rect.width | 0; const h = rect.height | 0;
      [drawCanvas, hudCanvas].forEach(c => { c.width = w; c.height = h; });
    }

    window.addEventListener('resize', fitCanvases);

    /*** CAMERA ***/
    async function startCamera() {
      try {
        const [w,h] = $('#resolution').value.split('x').map(Number);
        state.size = { w, h };
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            width: { ideal: w }, height: { ideal: h }, frameRate: { ideal: 60, max: 60 }, facingMode: 'user'
          }
        });
        video.srcObject = stream;
        await video.play();
        fitCanvases();
        state.running = true;
        tickFPS();
        showToast('C√¢mera inicializada.');
      } catch (err) {
        console.error(err);
        showToast('‚ö†Ô∏è N√£o foi poss√≠vel acessar a c√¢mera. Em Chrome, a webcam s√≥ funciona em origem segura (https ou localhost).', 6000);
      }
    }

    /*** TOAST ***/
    let toastTimer = null;
    function showToast(msg, ms=2200){
      ui.toast.textContent = msg; ui.toast.style.display = 'block';
      clearTimeout(toastTimer); toastTimer = setTimeout(()=> ui.toast.style.display='none', ms);
    }

    /*** MEDIAPIPE HANDS ***/
    let hands = null;
    function initHands(){
      hands = new Hands.Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({
        selfieMode: true,
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
      });
      hands.onResults(onResults);
    }

    /*** DRAW HELPERS ***/
    function lerp(a,b,t){ return a + (b-a)*t; }

    function drawLine(a,b){
      ctxDraw.beginPath();
      ctxDraw.moveTo(a.x, a.y);
      ctxDraw.lineTo(b.x, b.y);
      ctxDraw.lineJoin = 'round';
      ctxDraw.lineCap = 'round';
      ctxDraw.lineWidth = state.brush.width;
      if(state.erasing){
        ctxDraw.globalCompositeOperation = 'destination-out';
        ctxDraw.strokeStyle = 'rgba(0,0,0,1)';
      } else {
        ctxDraw.globalCompositeOperation = 'source-over';
        ctxDraw.strokeStyle = state.brush.color;
      }
      ctxDraw.stroke();
      ctxDraw.closePath();
    }

    function mapPoint(norm){
      // norm: {x:0..1, y:0..1} in video space. Account for mirror and video fit (cover)
      const vRect = video.getBoundingClientRect();
      const vw = vRect.width, vh = vRect.height;
      // MediaPipe gives normalized landmarks in input image space which matches the video when drawn with object-fit: cover and same canvas size.
      const x = norm.x * vw; const y = norm.y * vh;
      if(state.mirror) return { x: vw - x, y };
      return { x, y };
    }

    function distance(a,b){
      const dx = a.x - b.x, dy = a.y - b.y; return Math.hypot(dx,dy);
    }

    /*** MAIN RESULTS ***/
    function onResults(res){
      // Update fps
      const now = performance.now();
      const dt = now - state.lastFrameTime; state.lastFrameTime = now; state.fps = Math.round(1000/Math.max(dt,1));

      // Clear HUD
      ctxHUD.clearRect(0,0,hudCanvas.width,hudCanvas.height);

      const handsResults = res.multiHandLandmarks || [];
      state.handPresent = handsResults.length > 0;
      ui.handDot.className = 'dot ' + (state.handPresent ? 'ok' : 'warn');
      ui.handStatus.textContent = state.handPresent ? 'M√£o detectada' : 'M√£o n√£o detectada';
      ui.fps.textContent = state.fps + ' fps';

      if(!state.handPresent){ state.penDown = false; state.lastPt = null; ui.penStatus.textContent = 'OFF'; ui.penState.textContent = 'OFF'; return; }

      const lm = handsResults[0];
      state.landmarks = lm;

      // Gesture: pinch (thumb tip 4) with index tip (8)
      const t = lm[4]; const i = lm[8];
      const pinchDist = Math.hypot((t.x - i.x), (t.y - i.y));
      const penDownNow = pinchDist < state.pinchThreshold;

      // Update pen state
      state.penDown = penDownNow;
      ui.penStatus.textContent = penDownNow ? 'ON' : 'OFF';
      ui.penState.textContent = penDownNow ? 'ON' : 'OFF';

      // Track index tip as the pen point
      const penNorm = i; // normalized 0..1
      let pt = mapPoint(penNorm);

      // Smoothing (EMA)
      if(state.lastPt){
        pt = { x: lerp(state.lastPt.x, pt.x, state.ema), y: lerp(state.lastPt.y, pt.y, state.ema) };
      }

      // Draw if pen down
      if(state.penDown){
        if(state.lastPt){
          // Interpolate segments when far apart to avoid gaps
          const dx = pt.x - state.lastPt.x, dy = pt.y - state.lastPt.y;
          const dist = Math.hypot(dx,dy);
          const steps = Math.max(1, Math.min(12, Math.floor(dist / (state.brush.width * 0.6))));
          let prev = state.lastPt;
          for(let s=1;s<=steps;s++){
            const k = s/steps;
            const mid = { x: state.lastPt.x + dx*k, y: state.lastPt.y + dy*k };
            drawLine(prev, mid); prev = mid;
          }
        }
        state.lastPt = pt;
      } else {
        state.lastPt = null; // lift pen
      }

      // HUD overlay crosshair
      ctxHUD.save();
      ctxHUD.fillStyle = 'rgba(255,255,255,.6)';
      ctxHUD.beginPath(); ctxHUD.arc(pt.x, pt.y, 4, 0, Math.PI*2); ctxHUD.fill(); ctxHUD.restore();

      // Hologram drawing (landmarks + connections)
      drawHologram(lm);
    }

    function drawHologram(lm){
      const w = holoCanvas.width, h = holoCanvas.height;
      ctxHolo.clearRect(0,0,w,h);
      // Grid background
      ctxHolo.save();
      ctxHolo.globalAlpha = .4;
      ctxHolo.strokeStyle = 'rgba(255,255,255,.15)';
      for(let x=20;x<w;x+=20){ ctxHolo.beginPath(); ctxHolo.moveTo(x,0); ctxHolo.lineTo(x,h); ctxHolo.stroke(); }
      for(let y=20;y<h;y+=20){ ctxHolo.beginPath(); ctxHolo.moveTo(0,y); ctxHolo.lineTo(w,y); ctxHolo.stroke(); }
      ctxHolo.restore();

      const scale = Math.min(w,h) * 0.9;
      const ox = w/2, oy = h*0.55;

      // connections
      const conn = Hands.HAND_CONNECTIONS || [];
      ctxHolo.strokeStyle = 'rgba(34,211,238,.9)';
      ctxHolo.lineWidth = 2;
      conn.forEach(([a,b])=>{
        const pa = lm[a], pb = lm[b];
        const ax = ox + (state.mirror ? -(pa.x-.5) : (pa.x-.5)) * scale;
        const ay = oy + (pa.y-.6) * scale;
        const bx = ox + (state.mirror ? -(pb.x-.5) : (pb.x-.5)) * scale;
        const by = oy + (pb.y-.6) * scale;
        ctxHolo.beginPath(); ctxHolo.moveTo(ax, ay); ctxHolo.lineTo(bx, by); ctxHolo.stroke();
      });
      // points
      lm.forEach((p, idx)=>{
        const x = ox + (state.mirror ? -(p.x-.5) : (p.x-.5)) * scale;
        const y = oy + (p.y-.6) * scale;
        ctxHolo.beginPath(); ctxHolo.fillStyle = idx===8? '#fff' : 'rgba(255,255,255,.85)';
        ctxHolo.arc(x,y, idx===8? 3.5:2.5, 0, Math.PI*2); ctxHolo.fill();
      });
    }

    /*** RENDER LOOP TO FEED HANDS ***/
    async function processFrame(){
      if(!video.videoWidth){ requestAnimationFrame(processFrame); return; }
      await hands.send({ image: video });
      requestAnimationFrame(processFrame);
    }

    function tickFPS(){
      // Already computed per onResults; here just keeps UI updating
      ui.fps.textContent = state.fps + ' fps';
      if(state.running) requestAnimationFrame(tickFPS);
    }

    /*** SAVE ***/
    function savePNG(canvas, filename){
      const link = document.createElement('a');
      link.download = filename;
      link.href = canvas.toDataURL('image/png');
      link.click();
    }

    function saveArtOnly(){
      const tmp = document.createElement('canvas');
      tmp.width = drawCanvas.width; tmp.height = drawCanvas.height;
      const tctx = tmp.getContext('2d');
      tctx.drawImage(drawCanvas, 0,0);
      savePNG(tmp, 'airdraw-arte.png');
    }

    function saveWithVideo(){
      const tmp = document.createElement('canvas');
      tmp.width = drawCanvas.width; tmp.height = drawCanvas.height;
      const tctx = tmp.getContext('2d');
      // draw current video frame (respect mirror)
      tctx.save();
      if(state.mirror){ tctx.translate(tmp.width, 0); tctx.scale(-1,1); }
      tctx.drawImage(video, 0,0, tmp.width, tmp.height);
      tctx.restore();
      // draw art on top
      tctx.drawImage(drawCanvas, 0,0);
      savePNG(tmp, 'airdraw-com-video.png');
    }

    /*** CLEAR ***/
    function clearCanvas(){ ctxDraw.clearRect(0,0,drawCanvas.width, drawCanvas.height); }

    /*** UI BINDINGS ***/
    ui.color.addEventListener('input', e=>{ state.brush.color = e.target.value; ui.hex.value = e.target.value; });
    ui.hex.addEventListener('change', e=>{
      const v = e.target.value.trim();
      if(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i.test(v)){ state.brush.color = v; ui.color.value = v; }
      else { showToast('Hex inv√°lido. Use formato #RRGGBB.'); e.target.value = state.brush.color; }
    });

    ui.thickness.addEventListener('input', e=>{ state.brush.width = +e.target.value; ui.thicknessLabel.textContent = e.target.value; });
    ui.smoothing.addEventListener('input', e=>{ state.ema = +e.target.value; ui.smoothLabel.textContent = e.target.value; });
    ui.sensitivity.addEventListener('input', e=>{ state.pinchThreshold = +e.target.value; ui.sensitivityLabel.textContent = e.target.value; });

    ui.toggleDraw.addEventListener('click', ()=>{ state.penDown = !state.penDown; ui.penStatus.textContent = ui.penState.textContent = state.penDown?'ON':'OFF'; });
    ui.eraser.addEventListener('click', ()=>{ state.erasing = !state.erasing; ui.eraser.setAttribute('aria-pressed', String(state.erasing)); showToast(state.erasing? 'Borracha ON' : 'Borracha OFF'); });

    ui.mirror.addEventListener('click', ()=>{
      state.mirror = !state.mirror;
      document.documentElement.style.setProperty('--mirror', state.mirror? -1 : 1); // video uses scaleX(var(--mirror,1))
      ui.mirrorState.textContent = state.mirror? 'ON' : 'OFF';
      ui.mirrorMini.textContent = 'Mirror ' + (state.mirror?'ON':'OFF');
    });

    ui.clear.addEventListener('click', ()=>{ ui.confirm.showModal(); });
    ui.cancelClear.addEventListener('click', ()=> ui.confirm.close());
    ui.doClear.addEventListener('click', ()=>{ clearCanvas(); ui.confirm.close(); });

    ui.saveArt.addEventListener('click', saveArtOnly);
    ui.saveWithVideo.addEventListener('click', saveWithVideo);

    ui.restartCam.addEventListener('click', async ()=>{
      const s = video.srcObject; if(s){ s.getTracks().forEach(t=>t.stop()); }
      await startCamera();
    });

    ui.resolution.addEventListener('change', async ()=>{
      const s = video.srcObject; if(s){ s.getTracks().forEach(t=>t.stop()); }
      await startCamera();
    });

    /*** KEYBOARD ***/
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'd' || e.key === 'D'){ e.preventDefault(); ui.toggleDraw.click(); }
      if(e.key === 'e' || e.key === 'E'){ e.preventDefault(); ui.eraser.click(); }
      if(e.key === 'c' || e.key === 'C'){ e.preventDefault(); ui.clear.click(); }
      if(e.key === 's' || e.key === 'S'){ e.preventDefault(); ui.saveArt.click(); }
      if(e.key === 'm' || e.key === 'M'){ e.preventDefault(); ui.mirror.click(); }
      if(e.key === '+' || e.key === '='){ e.preventDefault(); ui.thickness.value = Math.min(60, +ui.thickness.value + 1); ui.thickness.dispatchEvent(new Event('input')); }
      if(e.key === '-' || e.key === '_'){ e.preventDefault(); ui.thickness.value = Math.max(1, +ui.thickness.value - 1); ui.thickness.dispatchEvent(new Event('input')); }
    });

    /*** INIT ***/
    function setupLayout(){
      // Ensure canvases match the rendered video size
      fitCanvases();
      // Mirror initial ON
      document.documentElement.style.setProperty('--mirror', -1);
    }

    async function init(){
      setupLayout();
      initHands();
      await startCamera();
      processFrame();
    }

    // Ensure getUserMedia exists
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      showToast('Este navegador n√£o suporta getUserMedia.');
    }

    window.addEventListener('load', init);

    // Accessibility: make controls focusable order sane
    $('#controls').querySelectorAll('button, input, select').forEach((el,i)=> el.setAttribute('tabindex', String(i+1)));
  })();
  </script>

  <!--
  README (resumo):
  - Como rodar: Abra este arquivo em um servidor est√°tico (ex.: VSCode Live Server / npx serve). 
    Por pol√≠tica do Chrome, acesso √† webcam N√ÉO funciona em file:// (origem n√£o segura). Em localhost ou https funciona.
  - Depend√™ncias via CDN: @mediapipe/hands e @mediapipe/drawing_utils.
  - Gestos: Junte polegar + indicador (pinch) para desenhar; m√£o aberta pausa. Bot√£o "Caneta" tamb√©m alterna manualmente.
  - UI: cor, espessura, borracha, limpar, salvar (arte/arte+v√≠deo), espelhar, sensibilidade, resolu√ß√£o.
  - Desempenho: 720p 30‚Äì60 fps em Chrome moderno; ajuste resolu√ß√£o se necess√°rio.
  - Privacidade: Tudo local, nada enviado a servidores.
  - Acessibilidade: Controles com r√≥tulos, foc√°veis; atalhos de teclado listados.
  - Limita√ß√µes: Sem origem segura, a c√¢mera n√£o inicializa (restri√ß√£o do navegador). Sem backend.
  -->
</body>
</html>
